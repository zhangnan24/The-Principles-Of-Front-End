# debounce 防抖函数怎么实现？

防抖的含义：触发事件后，在一段倒计时完成后才执行一次函数。如果在这段时间间隔又再次触发事件，则重新倒计时。

防抖函数实际上是返回一个包装过的函数，真正的执行逻辑被包装了起来，最简单实现如下：

这里有两个值得称道的点：**一个是修改了 this 的指向使其含义正确（指向调用该包装函数者），另外一个是支持包装函数传参。**

```js
function debounce(func, wait) {
  let timer = null;

  return function (...args) {
    const context = this;
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}
```

为啥我认为防抖不需要考虑立即执行的问题？因为防抖本身就是为了延时确认，个人认为立即执行和防抖的含义是相悖的。

# throttle 节流函数怎么实现

节流函数的话呢，有两种实现方式，一种是时间戳，一种是定时器。

这个倒是可以考虑要不要立即执行的问题。

```js
// 时间戳版本，会立即执行
function throttle(func, wait) {
  let prev = Date.now();

  return function (...args) {
    const context = this;
    const now = Date.now();
    if (now - prev >= wait) {
      func.apply(context, args);
      prev = Date.now();
    }
  };
}

// 定时器版本，会懒执行
function throttle(fn, wait) {
  let timer = null;

  return function (...args) {
    const context = this;
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args);
        timer = null;
      }, wait);
    }
  };
}
```

网上那种什么兜底方案是很愚蠢的，兜底是为了保证至少执行一次，上面的节流实现，无论是懒执行版本还是立即执行版本，都满足至少执行一次的要求。

另外最后唠一嘴关于传入函数的 this 指向问题，我们的初衷是：**包装前和包装后的 this 都应该是一致的。**

如果传一个箭头函数作为入参，本身箭头函数就没有自己的 this，包装后的 this 指向了全局对象 window，其实也没毛病，如下：

```js
const obj = {
  name: 'zhangnan',
  sayHello: () => console.log(this),
  throttleSayHello: throttle(() => console.log(this), 300)
}

obj.sayHello(); // window
obj.throttleSayHello(); // window
```

# 数组扁平化
