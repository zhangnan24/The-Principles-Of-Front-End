## 手写 promise

这个版本是可以实现 Promise 的两个核心功能：异步、值透传。

其中的`resolve`里面的`setTimeout`操作堪称天秀。

```js
// promise1
class MyPromise {
  constructor(executor) {
    this.data = undefined;
    this.cbs = [];

    const resolve = (value) => {
      this.data = value;
      // 确保then里面的回调先推入cbs数组，再取出来执行
      setTimeout(() => {
        this.cbs.forEach((cb) => cb(this.data));
      }, 0);
    };

    executor(resolve);
  }

  then(onResolved) {
    // promise2
    return new MyPromise((resolve) => {
      this.cbs.push(() => {
        const res = onResolved(this.data);
        if (res instanceof MyPromise) {
          res.then(resolve); // user-promise
        } else {
          resolve(res);
        }
      });
    });
  }
}
```

参考：[最简实现 Promise，支持异步链式调用（20 行）](https://juejin.cn/post/6844904094079926286)

## 手写 async/await

手写`async/await`不是要去实现这两个关键字的识别和转译，那种是 runtime 去做的，我们要做的是实现一个和`async/await`功能相同的东西：将**传统的 generator 函数转成自动执行的 generator 函数。**

```js
function generatorToAsync(generatorFn) {
  if (
    Object.prototype.toString.call(generatorFn) !== "[object GeneratorFunction]"
  ) {
    throw new Error("parameter must be a generator function");
  }

  return function () {
    const gen = generatorFn.apply(this, arguments);
    return new Promise((resolve, reject) => {
      function step(type, arg) {
        let res;
        try {
          res = gen[type](arg);
        } catch (err) {
          return reject(err);
        }
        const { value, done } = res;
        if (done) {
          return resolve(value);
        }
        return Promise.resolve(value)
          .then((data) => step("next", data))
          .catch((error) => step("throw", error));
      }

      step("next");
    });
  };
}
```

这个实现同样是参照了晨曦老哥的[手写async await的最简实现（20行）](https://juejin.cn/post/6844904102053281806)
