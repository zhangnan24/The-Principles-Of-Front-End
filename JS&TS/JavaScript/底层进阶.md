## apply, call 的作用和区别

apply 和 call 的作用都是：手动指定普通函数内 this 的指向，并立即执行该函数。

这里有两个要点：一是**普通函数**，二是立即执行。

普通函数，意味着它不能给箭头函数指定 this，箭头函数的 this 始终符合“向上找第一个包裹它的普通函数，如果没找到则指向全局对象”这个规则，不会被 apply/call 所左右。

第二是立即执行，比如：

```js
function sayHello() {
  console.log(this, "hello");
}

sayHello.apply({ name: "zhangnan" }); // {name: "zhangnan"} "hello"
```

而说到区别，则比较简单：给 sayHello 传入的参数中，apply 一定要包装在一个数组内，而 call 则是可以为多个参数。

推荐还是用apply吧，因为apply把参数严格定义为两个：**第1个是指定的this指向，第2个是给初始函数传入的参数合集，这个合集用一个数组包裹起来。**

而call的入参比较散落：**第1个是指定的this指向，第2个到第n个是给初始函数传入的参数合集。**

```js
function sayHello(name1, name2) {
  console.log(this, `${names[0]}and${names[1]}, are you OK?`);
}

sayHello.apply({ name: "zhangnan" }, ["张三", "李四"]);

sayHello.call({ name: "zhangnan" }, "张三", "李四");
```

## 初略了解ECMA提案阶段

- stage-0: 设想阶段，只是有一个想法
- stage-1: 提案阶段，有了比较全面的功能描述
- stage-2: 草案阶段，除了功能描述，还初步定义了API，以及实现一些实验性功能
- stage-3: 候选阶段，功能已经实现，需要测试验证
- stage-4: 已完成。验收通过就可以纳入正式标准

综上，一共5个阶段，一般来说能到stage-3的可以说是稳了，而stage-0则是不着边际随便提。

## 为什么0.1+0.2不等于0.3

这是一个比较底层的问题，因为这个十进制计算，对于计算机来讲还是二进制运算，像0.1对应的二进制的结果是无限循环的，而JavaScript的精度版本为IEEE 754，对于这种无限循环的二进制数字，会进行精度裁剪。

十进制转二进制主要分为两种情况：

- 十进制整数转二进制，规则是“除2取余，逆序输出”，一直到商为0时结束；
- 十进制小数转二进制，规则是“乘2取整，正数输出”，一直到小数为0的时候结束。

而对于0.1这个十进制小数来说，转成二进制是永远没法满足“小数部分为0”这个条件的，所以会得到一个无限循环的二进制数`0.000110011001100...`，而IEEE 754是有精度限制的，会对这个二进制数进行长度裁剪，造成精度丢失。

所以最后两个裁剪过的二进制数相加，再转化成十进制数，自然不是刚好等于0.3。

所以我们可以总结一下：在js中，涉及到小数的计算都很大可能存在精度问题，当然整数计算不会有这个问题。（整数和小数转成二进制的规则区别导致）
