## apply, call 的作用和区别

apply 和 call 的作用都是：手动指定普通函数内 this 的指向，并立即执行该函数。

这里有两个要点：一是**普通函数**，二是立即执行。

普通函数，意味着它不能给箭头函数指定 this，箭头函数的 this 始终符合“向上找第一个包裹它的普通函数，如果没找到则指向全局对象”这个规则，不会被 apply/call 所左右。

第二是立即执行，比如：

```js
function sayHello() {
  console.log(this, "hello");
}

sayHello.apply({ name: "zhangnan" }); // {name: "zhangnan"} "hello"
```

而说到区别，则比较简单：给 sayHello 传入的参数中，apply 一定要包装在一个数组内，而 call 则是可以为多个参数。

推荐还是用apply吧，因为apply把参数严格定义为两个：**第1个是指定的this指向，第2个是给初始函数传入的参数合集，这个合集用一个数组包裹起来。**

而call的入参比较散落：**第1个是指定的this指向，第2个到第n个是给初始函数传入的参数合集。**

```js
function sayHello(name1, name2) {
  console.log(this, `${name1}and${name2}, are you OK?`);
}

sayHello.apply({ name: "zhangnan" }, ["张三", "李四"]); // 这里的数组括号只是apply硬加的，实际上目标函数的参数还是一个一个传的

sayHello.call({ name: "zhangnan" }, "张三", "李四");
```

## bind怎么用

先来看看bind怎么用吧。

bind是挂在Function原型对象上的一个用于加工函数的函数，它的作用是产出一个绑定了this的新函数。当然，无论是call/apply/bind，这绑定this的三大神都是建立在普通函数的基础上的，对箭头函数没用。

需要注意的是：**bind函数可以先传入部分参数到新函数里面，新函数在使用时可以再传一点参数**。（有点函数柯里化的味道）

```js
// 基本使用 
const fn = function() {
  console.log(this.age)
};
const bindFn = fn.bind({ age: 26 });

fn(); // 相当于window.age，输出undefined
bindFn(); // 输出26


// 分批传参
const fn2 = function(gender, from) {
  console.log(this.age, gender, from)
};
const bindFn2 = fn2.bind({ age: 26 }, 'male');

fn2('male', 'china'); // undefined "male" "china"
bindFn2('china'); // 26 "male" "china"
```


## 从天而降的arguments

我们在执行js普通函数的时候（*对箭头函数没用*），常常会看到突然冒出来一个`arguments`变量，这个奇怪的现象其实是这样的：

在函数执行的时候，js会将函数的入参组装成一个类数组对象，作为该函数作用域下的一个变量，供函数体內代码调用。

当然，这是个局部变量，不会跑到函数体外面去，也不会挂到window下面，属于函数执行过程中产生的变量。

我们可以用`Array.from`来将这个类数组对象转成数组，这样可用性更高一些（能正常使用数组那些方法）。

```js
const arrowFn = ()  => {
  console.log(arguments, typeof arguments, window.arguments)
}

const normalFn = function() {
  console.log(arguments, typeof arguments, window.arguments)
}

arrowFn(3,5) // Uncaught ReferenceError: arguments is not defined

normalFn(3,5) // Arguments(2) [3, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] "object" undefined
```

## 初略了解ECMA提案阶段

- stage-0: 设想阶段，只是有一个想法
- stage-1: 提案阶段，有了比较全面的功能描述
- stage-2: 草案阶段，除了功能描述，还初步定义了API，以及实现一些实验性功能
- stage-3: 候选阶段，功能已经实现，需要测试验证
- stage-4: 已完成。验收通过就可以纳入正式标准

综上，一共5个阶段，一般来说能到stage-3的可以说是稳了，而stage-0则是不着边际随便提。

## 为什么0.1+0.2不等于0.3

这是一个比较底层的问题，因为这个十进制计算，对于计算机来讲还是二进制运算，像0.1对应的二进制的结果是无限循环的，而JavaScript的精度版本为IEEE 754，对于这种无限循环的二进制数字，会进行精度裁剪。

十进制转二进制主要分为两种情况：

- 十进制整数转二进制，规则是“除2取余，逆序输出”，一直到商为0时结束；
- 十进制小数转二进制，规则是“乘2取整，正数输出”，一直到小数为0的时候结束。

而对于0.1这个十进制小数来说，转成二进制是永远没法满足“小数部分为0”这个条件的，所以会得到一个无限循环的二进制数`0.000110011001100...`，而IEEE 754是有精度限制的，会对这个二进制数进行长度裁剪，造成精度丢失。

所以最后两个裁剪过的二进制数相加，再转化成十进制数，自然不是刚好等于0.3。

所以我们可以总结一下：**在js中，涉及到小数的计算都很大可能存在精度问题，当然整数计算不会有这个问题。（整数和小数转成二进制的规则区别导致）**

## new 的原理及具体过程

new操作在js里面是用来实例化对象的，有点类似于工厂函数的作用。

那么就让我们深入底层来看看new这个过程到底是怎样的：

1. 生成一个空的新对象；
2. 将新对象的`__proto__`指向构造函数的`prototype`，搭建原型关系；
3. 绑定this并执行构造函数内的代码，这一步相当于给新对象填充内容；
4. 如果构造函数显式地返回了一个引用类型（特殊情况），则返回该引用类型（对象/数组/函数都可）；否则返回新对象（绝大部分的正常情况）。

上面也提到了，在构造函数中显示返回值的两种情况：

- 构造函数如果返回原始值，那么这个返回值毫无意义
- 构造函数如果返回值为对象，那么这个返回值会被正常返回出去，构造函数內新生成的对象将不可用

所以，我们也发现了构造函数尽量不要返回值。因为返回原始值不会生效，而返回对象会导致 new 操作符失去意义，新建的对象没法返回出去给外面用。

## 闭包

闭包，在JS里面就是定义在函数内部的，可以访问外部函数*局部变量*的*子函数*，局部变量当然就包括外部函数自己定义的变量、以及外部函数的入参。而子函数能访问到外部函数局部变量则是利用了作用域链的特点。

闭包的应用有：模块化、柯里化。

## 啥是AST?

AST，简单来说就是抽象语法树，它是一种用对象来描述数据结构的方式。

## 装箱转换与拆箱转换

数组、对象要转成原始类型，目标都是转成字符串。

## 变量提升与函数声明提升

函数声明和变量声明都会提升，且函数声明的优先级高于变量声明。

这里的“高于”指的是函数声明会在当前作用域里面“浮”得更高一点，这也意味着：如果出现函数和变量同名的情况，因为函数浮得更高，将被后面的同名变量覆盖。

```js
var a = 1;
function a() {};

console.log(a); // 1
```

以上这段代码在提升后实际上会被处理成这样：

```js
function a() {};
var a = undefined;
a = 1;

console.log(a); // 1
```

## try...catch能捕获哪些错误？

先说结论：`try...catch`只能捕获到同步代码中的部分运行时错误（典型的如类型错误`TypeError`和引用错误`ReferenceError`），不能捕获任何异步中的错误和JS语法错误`SyntaxError`。

异步中的错误如：

- ajax请求错误
- Promise错误
- 放在宏任务/微任务中运行时产生的错误

JS语法错误则是一种解析器解析时产生的错误，如：

```js
let name = 'gg
```

以上这些都没办法被`try...catch`捕获到。

通常`try...catch`会用来捕获同步代码运行时的类型错误/引用错误，如：

```js
undefined.push(1) // 类型错误-TypeError

console.log(a) // 引用错误-ReferenceError
```

在`async/await`中，由于底层实现的`Iterator`迭代器的特殊机制，函数里面的代码可以当成同步代码来处理，可以用`try...catch`捕获错误。

## 原型链

1. 每个函数都有一个 `prototype` 属性;
2. 函数的 `prototype` 属性指向这个函数的原型对象；
3. `__proto__`不是一个标准的属性，应该用`getPrototypeOf`来代替;
4. `Object.prototype`是每条原型链的必经之路；
5. 原型对象的`constructor`会指回这个构造函数，也就是说构造函数和其原型对象是一种“互指”的关系；
6. 原型链的尽头是`null`；

一句话总结，什么是原型链：*原型链其实本质上就是一种链表，通过隐式原型`__proto__`，将分布在堆内存中不同的原型对象串联起来。*

## ES6的class怎么实现？

class本质是个fucntion，其实也就是es5中的那个经常大写开头的构造函数。

`class A extends B`其实就是：`A.prototype.__proto__ = B.prototype`。

而A里面我们经常会在`constructor`函数里添加一句`super(this)`，它表示：`B.constructor.apply(this)`
