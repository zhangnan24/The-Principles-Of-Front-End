## apply, call 的作用和区别

apply 和 call 的作用都是：手动指定普通函数内 this 的指向，并立即执行该函数。

这里有两个要点：一是**普通函数**，二是立即执行。

普通函数，意味着它不能给箭头函数指定 this，箭头函数的 this 始终符合“向上找第一个包裹它的普通函数，如果没找到则指向全局对象”这个规则，不会被 apply/call 所左右。

第二是立即执行，比如：

```js
function sayHello() {
  console.log(this, "hello");
}

sayHello.apply({ name: "zhangnan" }); // {name: "zhangnan"} "hello"
```

而说到区别，则比较简单：给 sayHello 传入的参数中，apply 一定要包装在一个数组内，而 call 则是可以为多个参数。

推荐还是用apply吧，因为apply把参数严格定义为两个：**第1个是指定的this指向，第2个是给初始函数传入的参数合集，这个合集用一个数组包裹起来。**

而call的入参比较散落：**第1个是指定的this指向，第2个到第n个是给初始函数传入的参数合集。**

```js
function sayHello(name1, name2) {
  console.log(this, `${name1}and${name2}, are you OK?`);
}

sayHello.apply({ name: "zhangnan" }, ["张三", "李四"]); // 这里的数组括号只是apply硬加的，实际上目标函数的参数还是一个一个传的

sayHello.call({ name: "zhangnan" }, "张三", "李四");
```

## bind怎么用

先来看看bind怎么用吧。

bind是挂在Function原型对象上的一个用于加工函数的函数，它的作用是产出一个绑定了this的新函数。当然，无论是call/apply/bind，这绑定this的三大神都是建立在普通函数的基础上的，对箭头函数没用。

需要注意的是：**bind函数可以先传入部分参数到新函数里面，新函数在使用时可以再传一点参数**。（有点函数柯里化的味道）

```js
// 基本使用 
const fn = function() {
  console.log(this.age)
};
const bindFn = fn.bind({ age: 26 });

fn(); // 相当于window.age，输出undefined
bindFn(); // 输出26


// 分批传参
const fn2 = function(gender, from) {
  console.log(this.age, gender, from)
};
const bindFn2 = fn2.bind({ age: 26 }, 'male');

fn2('male', 'china'); // undefined "male" "china"
bindFn2('china'); // 26 "male" "china"
```


## 从天而降的arguments

我们在执行js普通函数的时候（*对箭头函数没用*），常常会看到突然冒出来一个`arguments`变量，这个奇怪的现象其实是这样的：

在函数执行的时候，js会将函数的入参组装成一个类数组对象，作为该函数作用域下的一个变量，供函数体內代码调用。

当然，这是个局部变量，不会跑到函数体外面去，也不会挂到window下面，属于函数执行过程中产生的变量。

我们可以用`Array.from`来将这个类数组对象转成数组，这样可用性更高一些（能正常使用数组那些方法）。

```js
const arrowFn = ()  => {
  console.log(arguments, typeof arguments, window.arguments)
}

const normalFn = function() {
  console.log(arguments, typeof arguments, window.arguments)
}

arrowFn(3,5) // Uncaught ReferenceError: arguments is not defined

normalFn(3,5) // Arguments(2) [3, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] "object" undefined
```



## 初略了解ECMA提案阶段

- stage-0: 设想阶段，只是有一个想法
- stage-1: 提案阶段，有了比较全面的功能描述
- stage-2: 草案阶段，除了功能描述，还初步定义了API，以及实现一些实验性功能
- stage-3: 候选阶段，功能已经实现，需要测试验证
- stage-4: 已完成。验收通过就可以纳入正式标准

综上，一共5个阶段，一般来说能到stage-3的可以说是稳了，而stage-0则是不着边际随便提。

## 为什么0.1+0.2不等于0.3

这是一个比较底层的问题，因为这个十进制计算，对于计算机来讲还是二进制运算，像0.1对应的二进制的结果是无限循环的，而JavaScript的精度版本为IEEE 754，对于这种无限循环的二进制数字，会进行精度裁剪。

十进制转二进制主要分为两种情况：

- 十进制整数转二进制，规则是“除2取余，逆序输出”，一直到商为0时结束；
- 十进制小数转二进制，规则是“乘2取整，正数输出”，一直到小数为0的时候结束。

而对于0.1这个十进制小数来说，转成二进制是永远没法满足“小数部分为0”这个条件的，所以会得到一个无限循环的二进制数`0.000110011001100...`，而IEEE 754是有精度限制的，会对这个二进制数进行长度裁剪，造成精度丢失。

所以最后两个裁剪过的二进制数相加，再转化成十进制数，自然不是刚好等于0.3。

所以我们可以总结一下：**在js中，涉及到小数的计算都很大可能存在精度问题，当然整数计算不会有这个问题。（整数和小数转成二进制的规则区别导致）**

## new 的原理及具体过程


