## 函数式组件

为什么会出现函数式组件，因为类组件有不少缺点：

- 类组件中的 this 指向有点绕
- 通过选项去组织代码，在组件比较大的时候会很痛苦，因为类组件天生分离，不符合内聚性原则
- 组件复用不方便，尤其是 mixin，很容易带来数据来源指向不清楚的问题

官方脚手架`create react app`，一般简称为`CRA`。

首先我们要明白一件事情，**hooks 只能应用于函数式组件，不能用在类组件中。**

函数式组件的生命周期可以分为以下三部分：

初次渲染 ---> 重渲染 ---> 销毁

函数式组件会遵循一个非常有名的“纯粹模式”，如下：

```js
UI = render(data);
```

就是说当我们第一次使用函数式组件的时候，会触发初次渲染（`first-render`）；若其 props 改变，就会调用该 render 函数，触发重渲染(`re-render`)。

每一次的渲染，都是独立的。这正是函数式组件的美妙之处。

但是我们需要明确一个 ☝️ 概念：**渲染（初次渲染+重渲染）= 执行函数式组件内的代码 + 调用 render 方法**。但是执行函数式组件和触发 render 没有因果关系，因为 render 的执行与否，是 react 来决定的。

而 react 如何决定要不要调用 render 函数来更新 UI 视图呢？这取决于 data 有没有更新。在这里，`data = props + state`，也就是典型的属性加状态。

考虑到 render 取决于 data 变化，而 data 中的 state 数据是保存在链表中的。

链表的特性是啥？就是每个元素都有一个`next`指针指向下一个元素，一环扣一环关联起来。所以为什么 hooks 不能用在条件判断/循环/嵌套中，因为这些都不能保证每次渲染时读取 hooks 链表的顺序是完全一致的。尤其对于状态读取来说，读取顺序和初次渲染链表记录的顺序不一致，会直接导致一些 useState 钩子读取到错误的状态值。

```!
Only call hooks at the top level. 只在最顶层使用 Hook
```

## useMemo

useMemo 中的 memo，就是 memorize 的简写，也就是“记忆”的意思，它返回一个计算结果，它其实就相当于 vue 的 computed，都是用来缓存依赖某个数据的计算结果，如果依赖的数据改变了，则重新计算。

```js
const [count, setCount] = useState(0);

const doubleCount = useMemo(() => count * 2, [count]);
```

## useContext

所谓 Context，就是上下文，这个所谓的上下文，其实就是语文文章的上下文的意思。在软件开发领域我们可以这么理解：**上下文就是一个特定的环境**。

比如说：“哪里哪里”。在中国和汉语这个环境中，它表示谦虚；在欧美和英文环境中，它却表示在到处寻找某样东西。不同的外部环境，就是不同的上下文。

一个 web 项目是某一个页面的上下文，一个对象是里面某一个属性的上下文，诸如此类。

具体的用法后面再补吧。。

## useRef

关于 ref 的用法，我觉得最佳实践还是把作为一种 DOM 引用的方式比较合理。

案例也后面再补吧，这 hook 总算入了点门了，基本上搞清楚了大致的用法。

## 受控组件/非受控组件

区分受控组件与非受控组件，我们跳到宏观来看，不止于 form 表单组件，可以发现判断的标准就是：**上层对于该组件值的变更是否具备控制权。**

- 受控组件：受上层状态控制，子组件接收上层状态和改变上层状态的方法，有点类似于双向绑定；
- 非受控组件：和上层状态没有双向绑定关系，可能可以接收一个上层的值作为默认状态值，但是后面组件状态值更新不会通知给上层，上层只能通过类似 ref 的手段来获取组件状态值。

优先使用受控组件，必须操作 DOM 时（没法用上 react 的状态机制，比如文件上传、富文本等），才使用非受控组件。

## react VS vue

相同点：

- 都是数据驱动视图；
- 都使用 vdom 来操作 DOM，以优化性能；

不同点：

- vue 更像一种模板，html、js、css 严格分离；
- react 的 jsx 则将 js 和 html 进行了“混合”，某种程度上是更加灵活的
