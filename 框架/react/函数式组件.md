# 函数式组件

为什么会出现函数式组件，因为类组件有不少缺点：

- 类组件中的this指向有点绕
- 通过选项去组织代码，在组件比较大的时候会很痛苦，因为类组件天生分离，不符合内聚性原则
- 组件复用不方便，尤其是mixin，很容易带来数据来源指向不清楚的问题

=官方脚手架`create react app`，一般简称为`CRA`。

首先我们要明白一件事情，**hooks只能应用于函数式组件，不能用在类组件中。**

函数式组件的生命周期可以分为以下三部分：

初次渲染 ---> 重渲染 ---> 销毁

函数式组件会遵循一个非常有名的“纯粹模式”，如下：

```js
    UI = render(data)
```

就是说当我们第一次使用函数式组件的时候，会触发初次渲染（`first-render`）；若其props改变，就会调用该render函数，触发重渲染(`re-render`)。

每一次的渲染，都是独立的。这正是函数式组件的美妙之处。

# useMemo

useMemo中的memo，就是memorize的简写，也就是“记忆”的意思，它返回一个计算结果，它其实就相当于vue的computed，都是用来缓存依赖某个数据的计算结果，如果依赖的数据改变了，则重新计算。

```js
const [count, setCount] = useState(0);

const doubleCount = useMemo(() => count * 2, [count])
```

# useCallback

就是说每次渲染函数式组件的时候，里面的函数都会被重新创建一遍，为了避免重复创建函数节省性能开销，就出现了useCallback这个东西。所以我们可以把它归类为偏向于性能优化的一个hook，其实平常开发是没什么卵用。

# useContext

所谓Context，就是上下文，这个所谓的上下文，其实就是语文文章的上下文的意思。在软件开发领域我们可以这么理解：**上下文就是一个特定的环境**。

比如说：“哪里哪里”。在中国和汉语这个环境中，它表示谦虚；在欧美和英文环境中，它却表示在到处寻找某样东西。不同的外部环境，就是不同的上下文。

一个web项目是某一个页面的上下文，一个对象是里面某一个属性的上下文，诸如此类。


具体的用法后面再补吧。。

# useRef

关于ref的用法，我觉得最佳实践还是把作为一种DOM引用的方式比较合理。

案例也后面再补吧，这hook总算入了点门了，基本上搞清楚了大致的用法。



