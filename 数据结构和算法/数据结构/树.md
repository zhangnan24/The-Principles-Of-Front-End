## 概述

树，简单来说就是一种强调**分层**的数据结构。前端这边的话，比较常遇到的就是 DOM 树、级联选择、树形控件这些。

JS 里面没有树这个数据结构，但是可以用`Object`+`Array`来模拟树。

```js
// 举个栗子🌰 这就是分层
{
  value: 'root',
  children: [
    {
      value: '熊大',
      children: [
        {
          value: '熊大小崽1'
        },
        {
          value: '熊大小崽2'
        }
      ]
    },
    {
      value: '熊二',
      children: [
        {
          value: '熊二小崽1'
        }
      ]
    }
  ]
}
```

对树的常见操作包括深度/广度优先遍历，前中后序遍历。

## 广度优先遍历

广度优先遍历，其实就是一种*分层*访问树结构的方式，访问顺序是从最顶层节点 --> 最底层节点。

而说到它的实现，我认为用**队列**来做堪称一绝，其思路如下：

1. 新建一个队列，将根节点入队；
2. 队头出队并访问；
3. 如果出队的队头有children，则挨个推入到队尾；
3. 重复2、3步操作，一直到队列为空。

实现如下：

```js
const tree = {
  val: "root",
  children: [
    {
      val: "b",
      children: [
        {
          val: "b1",
        },
        {
          val: "b2",
        },
      ],
    },
    {
      val: "c",
      children: [
        {
          val: "c1",
        },
        {
          val: "c2",
        },
      ]
    },
  ],
};

// 广度优先遍历，英文bound first search
const bfs = (root) => {
  const queue = [root];
  while(queue.length) {
    const head = queue.shift();
    console.log(head.val);
    if (head.children) {
      head.children.forEach(child => queue.push(child))
    }
  }
}

bfs(tree);
```

## 深度优先遍历

深度优先遍历，是一种*逐步*访问树结构的方式，访问顺序和我们平时看书的顺序类似，就是先从第一章的第一节的第一段开始看起，尽可能深地访问树结构。

深度优先遍历的最简单实现，就是递归，它由以下两步构成：

1. 访问根节点；
2. 对根节点的 children 挨个进行深度优先遍历。

coding 实现如下：

```js
const tree = {
  val: "root",
  children: [
    {
      val: "b",
      children: [
        {
          val: "b1",
        },
        {
          val: "b2",
        },
      ],
    },
    {
      val: "c",
      children: [
        {
          val: "c1",
        },
        {
          val: "c2",
        },
      ]
    },
  ],
};

// 深度优先遍历，英文deepFisrtSearch，简称dfs
const dfs = (root) => {
  console.log(root.val);
  if (root.children) root.children.forEach(dfs)
}

dfs(tree);
```

## 二叉树的前中后序遍历（基础版）

在谈论这个问题之前，我们先来看看，啥是“二叉树”。

二叉树，就是每个节点**最多**只有两个子节点的树形结构。在JS中，我们一般用`Object`来模拟二叉树，如下：

```js
// 因为最多只有两个节点，所以命名为左子树、右子树
// 只要节点存在，就一定有val值，只是说left/right可能为空
const binaryTree = {
  val: 1,
  left: {
    val: 2,
    left: {
      val: 3
    },
    right: {
      val: 4,
    }
  },
  right: {
    val: 5,
    left: null,
    right: {
      val: 6
    }
  }
}
```

### 先序遍历

二叉树的先序遍历，指的是：

1. 访问根节点；
2. 对根节点的左子树进行先序遍历；
3. 对根节点的右子树进行先序遍历。

先序遍历的实现如下：

```js
const preOrder = (root) => {
  if (!root) return;

  console.log(root.val);
  preOrder(root.left);
  preOrder(root.right);
}

preOrder(binaryTree);
```
简单来说：就是**根 --> 左 --> 右**。

### 二叉树的中序遍历

中序遍历和前序遍历的区别仅仅在于顺序，为：**左 --> 根 --> 右**

1. 先对根节点的左子树进行中序遍历；
2. 访问根节点；
3. 对根节点的右子树进行中序遍历。

实现如下：

```js
const inOrder = (root) => {
  if (!root) return;

  inOrder(root.left);
  console.log(root.val);
  inOrder(root.right);
}

inOrder(binaryTree);
```

### 后序遍历

后序遍历也是类似的，就是换了个顺序，变成了**左 --> 右 --> 根**

1. 先对根节点的左子树进行后序遍历；
2. 对根节点的右子树进行后序遍历；
2. 访问根节点。

实现如下：

```js
const postOrder = (root) => {
  if (!root) return;

  postOrder(root.left);
  postOrder(root.right);
  console.log(root.val);
}

postOrder(binaryTree);
```

### 遍历顺序记忆

那么我们应该如何记忆这几个顺序呢？我认为用**从左到右画三角箭头**的方式来记忆是非常不错的。

- 前序遍历。就是一个画了个指向左边的箭头⬅️，即 **根 -> 左 -> 右**
- 中序遍历。就是一个画了个指向上面的箭头⬆️，即 **左 -> 根 -> 右**
- 后序遍历。就是一个画了个指向右边的箭头➡️，即 **左 -> 右 -> 根**



## 前中后序遍历（高级版）

## 二叉树的最大深度

## 二叉树路经总和
