## 概述

树，简单来说就是一种强调**分层**的数据结构。前端这边的话，比较常遇到的就是 DOM 树、级联选择、树形控件这些。

JS 里面没有树这个数据结构，但是可以用`Object`+`Array`来模拟树。

```js
// 举个栗子🌰 这就是分层
{
  value: 'root',
  children: [
    {
      value: '熊大',
      children: [
        {
          value: '熊大小崽1'
        },
        {
          value: '熊大小崽2'
        }
      ]
    },
    {
      value: '熊二',
      children: [
        {
          value: '熊二小崽1'
        }
      ]
    }
  ]
}
```

对树的常见操作包括深度/广度优先遍历，前中后序遍历。

## 广度优先遍历

广度优先遍历，其实就是一种*分层*访问树结构的方式，访问顺序是从最顶层节点 --> 最底层节点。

而说到它的实现，我认为用**队列**来做堪称一绝，其思路如下：

1. 新建一个队列，将根节点入队；
2. 队头出队并访问；
3. 如果出队的队头有children，则挨个推入到队尾；
3. 重复2、3步操作，一直到队列为空。

实现如下：

```js
const tree = {
  val: "root",
  children: [
    {
      val: "b",
      children: [
        {
          val: "b1",
        },
        {
          val: "b2",
        },
      ],
    },
    {
      val: "c",
      children: [
        {
          val: "c1",
        },
        {
          val: "c2",
        },
      ]
    },
  ],
};

// 广度优先遍历，英文bound first search
const bfs = (root) => {
  const queue = [root];
  while(queue.length) {
    const head = queue.shift();
    console.log(head.val);
    if (head.children) {
      head.children.forEach(child => queue.push(child))
    }
  }
}

bfs(tree);
```

## 深度优先遍历

深度优先遍历，是一种*逐步*访问树结构的方式，访问顺序和我们平时看书的顺序类似，就是先从第一章的第一节的第一段开始看起，尽可能深地访问树结构。

深度优先遍历的最简单实现，就是递归，它由以下两步构成：

1. 访问根节点；
2. 对根节点的 children 挨个进行深度优先遍历。

coding 实现如下：

```js
const tree = {
  val: "root",
  children: [
    {
      val: "b",
      children: [
        {
          val: "b1",
        },
        {
          val: "b2",
        },
      ],
    },
    {
      val: "c",
      children: [
        {
          val: "c1",
        },
        {
          val: "c2",
        },
      ]
    },
  ],
};

// 深度优先遍历，英文deepFisrtSearch，简称dfs
const dfs = (root) => {
  console.log(root.val);
  if (root.children) root.children.forEach(dfs)
}

dfs(tree);
```

## 前中后序遍历（基础版）

## 前中后序遍历（高级版）

## 二叉树的最大深度

## 二叉树路经总和
