# 复杂度有啥用

用来定性分析算法的运行时间和占用内存空间，作为算法性能优化的参考。一个算法占用内存越小，运行时间越短，说明这个算法性能越好。

# 大 O 函数

大 O 函数一般这么几种，O(1)，O(logN)，O(n)，O(n^2)，O(n^3)...，例子里面的复杂度逐渐递增。

> 一般来说，我们把 log2N 和 logN 等价，所以这里也可以看出时间复杂度并不是为了去描述这个算法具体会跑多少秒，而是把归类为什么复杂度级别。log2N，log3N 的复杂度都可以视为 logN。

# 时间复杂度

定性描述一个算法的运行时间，就叫做时间复杂度。它的形式为“大 O 函数”。

所谓定性，就是指不会定量地描述该算法跑完需要多少秒，而是一种大概的用时描述。

时间复杂度的常用套路就是看**里面的循环会跑几次**。

## O(1)时间复杂度

如下示例：

```js
let i = 1;
i += 1;
```

它的时间复杂度即为 O(1)，为什么是 O(1)？因为这段代码每次执行的时候，只会跑 1 遍，它里面没有任何循环。

## O(logN)时间复杂度

如下：

```js
let i = 1;

while (i < N) {
  console.log(i);
  i *= 2;
}
```

根据我们中学数学来说：`2^x = N`，两边取对数，即得`x = log2N`，也就是说这段循环执行的次数大概在 log2N 次左右（因为 log2N 不一定是整数）就可以跳出去，所以大概循环 log2N 次。

无论是 log2N、log3N 还是 log4N，我们都把它归位 logN 复杂度这一档，所以这里是时间复杂度为 O(logN)。

## O(n)时间复杂度

看看下面这段代码：

```js
const len = 10;
for (let i = 0; i < len; i += 1) {
  console.log(i);
}
```

这里的关键变量 len 的长度为 10，这个 for 循环就要循环 10 次；假如 len 为 20，那么 for 循环则循环 20 次；假如 len 为 n，那么 for 循环就要循环 n 次。

所以这段代码的时间复杂度就是 O(n)。

其实看到这里我们已经大概可以总结出来：_看一段代码的复杂度，实际就是在看这段代码里面的循环跑了几次。_

# 空间复杂度

定性描述一个算法运行需要临时占用的内存空间，即空间复杂度，形式也为“大 O 函数”，它也是一种大概的描述。

空间复杂度的常用套路就是看**同一个地方存储变量的“单元格”是多少个**。

而空间复杂度，因为只存了一个变量，空间复杂度也为 O(1)。

## O(1)空间复杂度

如下示例：

```js
let i = 1;
i += 1;
```

这段代码只声明了单个变量，空间复杂度为 O(1)。

## O(n)空间复杂度

看看下面这段代码：

```js
const list = [];
for (let i = 0; i < n; i += 1) {
  list.push(i);
}
```

在这个数组里面，添加了 n 个值，也就是占用了 n 个内存单元，故空间复杂度为 O(n)。

## O(n^2)空间复杂度

看看下面这段代码：

```js
const matrix = [];
for (let i = 0; i < n; i += 1) {
  matrix.push([]);
  for (let j = 0; j < n; j += 1) {
    matrix[i].push(j);
  }
}
```

这里存了个二维数组，也就是所谓的“矩阵”。占用的内存单元数目为 n\*n，故空间复杂度为 O(n^2)。

## 当复杂度并列怎么算

假如有多个复杂度并列，比如 O(1) + O(logN) + O(n)，_取复杂度最高的作为这段代码的复杂度即可_。如：

- O(1) + O(1) ==> 复杂度为 O(1)
- O(1) + O(logN) + O(n) ==> 复杂度为 O(n)
- O(n) + O(n) ==> 复杂度为 O(n)
