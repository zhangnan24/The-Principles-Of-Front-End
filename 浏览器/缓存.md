# 浏览器缓存的基本认识

首先我们形成一种认识：我们常常说的缓存缓存，对于前端来说，一般无非就是两种：**强缓存、协商缓存。**

在优先级这方面：强缓存 > 协商缓存。

# 强缓存

所谓强缓存，意思就是说假如缓存在有效期内，就直接取该缓存，甚至都不会去发http请求。

强缓存有两个典型的字段：Expires和Cache-Control。Expires是HTTP1.0的产物，用于设置一个具体的过期时间，当然因为服务器和客户端的时间定义有可能不一致（比如客户端人为修改了本地时间），所以从HTTP1.1开始，采用Cache-Control作为Expires的替代品。

Cache-Control比Expires更靠谱的原因是：它以max-age作为键，以具体过期秒数作为值。类似一个秒数倒计时的机制，这样就避开了客户端与服务端时间定义不一致而可能导致的问题，非常精准。

害，真尼玛就cookie翻版呗。Expires仍然是用来设置过期时间的，时间依然还是格林尼治时间，类似下面这样：

```js
Expires: Mon, 12 Aug 2020 11:10:23 GMT
```

至于Cache-Control，则是这样：

```js
Cache-Control: max-age=86400
```
而且毫无悬念地，优先级还是cookie里面那一套：Cache-Control > Expires

我们可以归纳一下，强缓存的主要特点如下：

- 如果同时设置了Expires和Cache-Control，Cache-Control优先级更高；
- 如果Expires和Cache-Control两个都失效了，也不会直接向服务器请求相关资源，而是进入协商缓存。


# 协商缓存

协商缓存的整体流程是这样的：客户端向服务器发起一个资源请求，并在请求头中携带之前服务器返回的该资源的信息（比如最后修改时间、文件指纹等），服务器收到这个请求后，会拿客户端传过来的文件信息去和服务器上该资源的文件信息做对比。

- 如果不一致，说明服务器该资源更新过，就按正常请求流程将最新的该资源传输至客户端；
- 如果一致，说明没更新过，服务器此时会直接返回一个简单的消息给客户端，通知客户端拿自己浏览器之前缓存的对应资源来用就行了。

因为如果说客户端资源A的信息和服务端资源A的信息完全一致，确实就没必要再传输资源A了，毕竟当资源很大的时候，资源传输还是很耗时的。

拿目前来说，文件信息主要有两个重要指标，用来判断文件有没有更新。一个是Last-Modified（最后修改时间），另外一个则是Etag（文件指纹）。


## Last-Modified

如果是要设置协商缓存，服务器会在客户端第一次请求该资源时，在响应头中带上一个`Last-Modified`字段，字段的值即为该文件到目前为止的最后修改时间。

下次当客户端再次请求该资源时，就会在请求头中带上一个`If-Modified-Since`字段，字段值为之前的修改时间，意思为询问服务器该资源自从xxx时间后是否更新过。

服务器收到请求后，拿着客户端传过来的最后修改时间和服务器中该真正资源的最新最后修改时间比对：

- 假如不一致，说明服务器中的该资源比较新，就按正常请求流程返回最新资源给客户端；
- 假如一致，说明服务器中该资源其实没更新过，这时候会返回304简单消息，告诉客户端去取之前客户端自己存的缓存。

## Etag

Etag其实会比Last-Modified更科学一些，我们可以称其为文件指纹。它类似于一个随机生成的长字符串，我们可以认为它是不会重复的。比如采用MD5算法来搞，只要文件变动，对应的这个文件指纹就会变化。

```!
注意⚠️：这里的文件指纹变化并不代表文件名会变化!
```

然后流程就跟上面的比较类似了。都是第一次请求时服务器在响应头带上一个`Etag`字段，下次客户端请求该资源时在请求头带上一个`If-None-Match`字段，询问服务器是否在服务器的资源中没有和当前携带文件指纹匹配的文件（也就是更新过）。如果没有匹配到任意资源，则返回该最新资源；如果匹配到了某个资源，则返回304。

在优先级上，Etag高于Last-Modified，也就是说如果两个都有，会优先取Etag。

## 为什么Last-Modified的精度还是不行？

在协商缓存中的Last-Modified中，我们全程都是用服务器中的时间，并不存在什么客户端时间跟服务器时间可能不一致这种问题，那为什么说Last-Modified的精度还是不如Etag呢？其实是因为Last-Modified主要存在下面两个缺点：

- 能感知的最小单位是秒。假如第一次请求和第二次请求的时间间隔小于1s，但是服务器却在这不足一秒的短短时间内改变了多次，Last-Modified是没法感知这种精度级别的修改的。我们可以这么说：Last-Modified应对那种毫秒级的文件改变十分乏力。（当然如果是经常毫秒级的变化我觉得也没必要做缓存了）

- 最后修改时间变化不一定表示文件真的变化了。这个最后修改时间是否变化，取决于你是否打开了编辑模式，而不是去对比文件是否真的改变了。也就是说，假如一个文件，我只是用vim打开编辑，但是我一个字没改又保存退出了，这个文件的最后修改时间还是变了。