## 什么叫并行处理？

所谓并行，就是说能同时干好几件事。

## 进程 vs 线程

进程大，线程小。

我们启动一个程序，就会生成一个实例，这个实例提供一块内存来存放这个当前程序的**静态代码和运行状态**。我们把这个实例称之为“进程”。

线程是在进程里面存活的，如果我们把进程比作一个容器的话，线程就是在这个容器里面跑来跑去干活的小弟，这些线程小弟干的活，就叫做“任务”。几个线程小弟同时干活，就可以把这种情况称为“并发任务”。

在这个容器里面有这样两个特点：

- 如果容器里面的某个线程小弟挂了，这个容器可能也会受到影响并且直接挂掉；
- 所有的线程小弟之间可以共享数据，彼此没什么隐私可言；
- 当进程容器被打碎，这块内存空地就得被回收掉 ♻️，腾出地方给别人用；
- 各个进程容器之间相互隔离，互不影响。如果需要通信，则需要使用特殊的 IPC 进程间通信管道。

## 浏览器结构

一个浏览器大致可以分为**用户界面、浏览器引擎、渲染引擎**三大部分。

这里的用户界面指的是窗口头上的操作区域，比如地址栏、前进后退按钮、书签栏等、Tab 标签页等。

浏览器引擎，虽然这个名字很唬人，但是实际上这玩意只是个跑腿的，它负责在用户界面和渲染引擎之间传递指令。

渲染引擎就是负责把页面渲染到窗口中的引擎，这个渲染引擎不仅仅是说画画图那么简单，实际上它才是浏览器的大佬，它还有个牛逼的名字，叫“内核”。

说到内核，又不得不说一下各大主流浏览器的内核：

|   IE    | Safari | Firefox |        Chrome、Opera、Edge        | 360 浏览器、QQ 浏览器、搜狗浏览器 |
| :-----: | :----: | :-----: | :-------------------------------: | :-------------------------------: |
| Trident | Webkit |  Gecko  | 基于开源 webkit 改造的 blink 内核 |       Trident+Blink 双内核        |

这里要着重说一下 webkit 和 blink，首先 webkit 是苹果的首创发明，牛皮。出于开源精神，苹果把这玩意贡献到了社区。

就连平时牛的不行的谷歌，也只是套用现成的 apple 写好的 webkit 内核，然后在上面改改东西，重新命名 blink，就包装成了自家内核。在升级了 blink 之后，出于历史兼容性的考虑，`navigator.userAgent`对这一升级并未有所体现，其字段仍沿用`AppleWebKit`。

渲染引擎下面主要包括网络请求模块、JS 解释器这两个大头。

用户界面

## 古老的单进程浏览器时代

这里主要是吐槽一下单进程浏览器存在的三个缺点。

很久很久以前，浏览器其实是单进程的，里面包括页面渲染线程、JS 线程等。它的缺点主要如下：

- 根据进程和线程的关系我们知道，一个线程挂了，其所在的整个进程可能会挂，所以说第一个缺点是**不稳定**
- 根据进程和线程的关系我们又知道：同一个进程内的所有线程是无隐私共享数据的， JS 线程能获得浏览器当前进程的所有数据，这是第二个缺点：**不安全**
- 还有就是一个线程负责的东西太多，这就导致第三个缺点：**不流畅**

## 现代化的多进程浏览器结构

现代浏览器是多进程的结构，简单来说，一个标签页就对应一个独立的渲染器进程。所以，你开很多少个标签页，就会启动多少个进程，这样虽然有点废内存空间，但确实是最安全的，因为不同标签页对应的不同进程之间互不影响。

现代浏览器根据功能不同，主要分为以下几种进程：

- 浏览器进程。这个进程负责**用户界面**，也就是地址栏，书签栏，前进后退按钮那一堆东西。另外这个进程也是个大组长，负责浏览器里面不同进程之间的工作协调
- 渲染器进程。 负责窗口的内容显示，每个标签页都会对应一个渲染器进程
- 网络进程。负责搞网络请求的
- GPU 进程。就是个画图、绘制页面的
- 插件进程。负责管理浏览器插件（如 flash）
- 缓存进程。负责搞缓存的

## 为什么说 JS 是单线程的

JS 单线程指的是说：**在一个渲染器进程中，有且只有一个 JS 线程在工作。**

这样可以保证 DOM 的操作可靠性。假如有多个 JS 线程同时工作，一个 JS 线程在删除该 DOM，另一个 JS 线程却在获取该 DOM 的信息，这样就没法保证操作的可靠性。

## JS 执行线程与 UI 线程互斥的根本原因

这两者互斥的根本原因在于：**JS 是可以操作 DOM，导致样式改变的。**

假设有 4 个红色的 div 等待渲染到页面上，JS 线程和 UI 线程同时启动。UI 线程在拿着“4 个红色 div”的稿子老老实实画着图，JS 线程来捣一手乱，把 div 改为蓝色同时数量缩减为 3 个。那代码跟页面展示效果就不一致了。

所以，为了避免这种代码数据跟页面展示不一致的异常情况，浏览器将 JS 线程和 UI 线程设置成了互斥的关系，当 JS 线程在干活时，UI 线程会被挂起来，晾在一边乖乖等待。等到 JS 线程把活干完喘口气的时候，UI 线程才会跑出来执行一遍。

## 浏览器的异步机制如何实现？

浏览器的异步机制是由两个或两个以上的常驻线程完成。

比如异步请求，先是**JS 执行线程**解析到此处是一个异步请求，然后由**http 异步请求线程**发起异步请求，然后未来某一时刻**事件触发线程**灵敏地察觉到请求已经完成了，就会把完成后的回调插入到微任务队列末尾里等待被执行；

又比如`setTimeout`这种东西，先是**JS 执行线程**解析到此处是一个定时器动作，然后这部分代码放到**定时器线程**去做倒计时，倒计时完成后，**定时器线程**再把对应的回调函数插入到宏任务队列末尾里等待被执行

## 浏览器的 V8 垃圾回收机制

这里说的堆中的垃圾回收。

在老一代浏览器中，浏览器对于垃圾回收的策略是“引用计数”，这是一种比较古老的方法。

而在现代浏览器中，判断一个对象是不是垃圾数据，都是看这个对象的可达性（能不能被访问到），如果不能在任何地方被访问到，就会被标记为孤岛数据，也就是垃圾数据。

“标记-清除”，是现代浏览器垃圾回收的核心机制。在 v8 内核的浏览器中，会基于这个机制做一些更加全面的扩展，也就是所谓的“**分代回收机制**”，具体如下：

- 堆内存会被分为“新生代空间”和“老生代空间”
- 新生代空间小，一般用来存放一些“短命鬼”；老生代空间大，一般用来存放一些“老油条”
- 新生代空间里面又被划分为对象区、空闲区，这两个空间在执行垃圾回收时会“相互倒腾”
- 老生代空间主要机制是“标记-清除”+“标记-整理”

### 新生代怎么回收

在新生代空间执行垃圾回收时，会“相互倒腾”，这个是怎么回事呢？对象区顾名思义就是用来存放浏览器认为的“短命鬼”对象的；而空闲区域顾名思义就是空闲的。当对象区内存不足的时候，就会对对象区里面的所有对象进行标记，可达的对象会被依次复制剪切到空闲区，不可达的数据则清除掉。

当这个动作完成以后，对象区和空闲区的角色也就互换了。

然而新生代空间的容量毕竟是有限的，当倒腾两次后，仍然存活的对象将晋升到更加广阔的老生代空间。除此之外，占用对象区空间超过 25%的大型对象也会晋升到老生代空间。

### 老生代怎么回收

老生代空间由于范围比较大，对象体积普遍也比较大，就不太适合复制这种耗时操作了，它主要使用的手法是*标记-清除*和*标记-整理*。

标记-清除很好理解，就是在一轮标记后，将孤岛数据原地清除。

但是原地清除这个操作也会带来大量的不连续内存空间，俗称“内存碎片”。为了尽可能地空出连续内存，需要对存活的老油条对象们进行整理，简单来说：_就是尽可能往老生代空间某的一端挤，空出连续的“内存空地”。_

## 关于 postMessage

`postMessage`常用于两个窗口之间的通信，最典型的场景就是：**一个页面嵌套一个 iframe，父页面和 iframe 之间互发消息进行通信**。

`postMessage`最大的特点就是可以跨域，注意：`postMessage`的调用窗口是要发送的窗口，也就是目标窗口，而不是当前窗口，这也是一个比较容易搞错的地方。

```js
// 父页面
const iframe = document.querySelector("#ifr");
iframe.onload = function() {
  iframe.contentWindow.postMessage("来自父组件的消息", iframe.src);
}

window.onmessage = (e) => {
  console.log("子页面发过来的消息为", e.data);
};
```

```html
<!-- 父页面 -->
<iframe src="http://192.168.96.171:8080/" id="ifr" title="子页面" />
```

那么在 iframe 子页面，就可以这样：

```js
window.onmessage = function (e) {
  if (e.source !== window.parent) return; // 判断一下是不是父页面传过来的，过滤一下，这样比较安全
  console.log("父页面颁发的消息为：", e.data);
};

window.parent.postMessage("我是你的儿", "http://192.168.0.101:3000"); // 注意这里要直接写父页面的地址
// window.parent.postMessage("我是你的儿", "*"); // 或者粗暴一点，信号乱射
```

## window.BroadcastChannel，一个孤独的同源广播器

这个是window下面的一个构造函数，用来实例化一个信道，以接入某个广播📢。

`BroadcastChannel`的优点很明显，不同于传统的`postMessage`点对点的通信，这个是可以一对多的。

```js
// A标签页
var channel1 = new BroadcastChannel('channel_for_emotion');

aa.postMessage('所有人听令'); // 这里不用指定某一个origin，因为这个消息是广播式的
```

```js
// B标签页，channel_for_emotion是该频道的标识，接入就行了
var myChannel = new BroadcastChannel('channel_for_emotion');

myChannel.onmessage = function(e) {
  console.log(e.data); // A页面执行广播动作后，这里会打印出“所有人听令”
}
```

当然，它的缺点也比较明显：

1. 只能同源；
2. 兼容性一般，IE和safari全系不支持。（这个情况可能可以通过polyfill来减缓）