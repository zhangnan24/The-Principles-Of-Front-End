# 什么叫并行处理？

所谓并行，就是说能同时干好几件事。

# 进程 vs 线程

线 🧵 是很细的，进程大，线程小。

就是说我们启动一个程序，就会生成一个实例，这个实例提供一块内存来存放这个当前程序的**静态代码和运行状态**。我们把这个实例称之为“进程”。

线程是在进程里面存活的，如果我们把进程比作一个容器的话，线程就是在这个容器里面跑来跑去干活的小弟，这些线程小弟干的活，就叫做“任务”。几个线程小弟同时干活，就可以把这种情况称为“并发任务”。

在这个容器里面有这样两个特点：

- 如果容器里面的某个线程小弟挂了，这个容器就臭掉了，然后崩溃裂开来卧槽；
- 所有的线程小弟之间可以共享数据，彼此没什么隐私可言；
- 当进程容器被打碎，这块内存空地就得被回收掉 ♻️，腾出地方给别人用；
- 各个进程容器之间相互隔离，互不影响。如果需要通信，则需要使用特殊的 IPC 进程间通信管道。

# 浏览器结构

一个浏览器大致可以分为**用户界面、浏览器引擎、渲染引擎**三大部分。

这里的用户界面指的是窗口头上的操作区域，比如地址栏、前进后退按钮、书签栏等、Tab 标签页等。

浏览器引擎，虽然这个名字很唬人，但是实际上这玩意只是个跑腿的，它负责在用户界面和渲染引擎之间传递指令。

渲染引擎就是负责把页面渲染到窗口中的引擎，这个渲染引擎不仅仅是说画画图那么简单，实际上它才是浏览器的大佬，它还有个牛逼的名字，叫“内核”。

说到内核，又不得不说一下各大主流浏览器的内核：

|   IE    | Safari | Firefox |        Chrome、Opera、Edge        | 360 浏览器、QQ 浏览器、搜狗浏览器 |
| :-----: | :----: | :-----: | :-------------------------------: | :-------------------------------: |
| Trident | Webkit |  Gecko  | 基于开源 webkit 改造的 blink 内核 |       Trident+Blink 双内核        |

这里要着重说一下 webkit和blink，首先webkit是苹果的首创发明，牛皮。出于开源精神，苹果把这玩意贡献到了社区。

就连平时牛的不行的谷歌，也只是套用现成的apple写好的webkit内核，然后在上面改改东西，重新命名blink，就包装成了自家内核。在升级了blink之后，出于历史兼容性的考虑，`navigator.userAgent`对这一升级并未有所体现，其字段仍沿用`AppleWebKit`。

渲染引擎下面主要包括网络请求模块、JS 解释器这两个大头。

用户界面

# 古老的单进程浏览器时代

这里主要是吐槽一下单进程浏览器存在的三个缺点。

很久很久以前，浏览器其实是单进程的，里面包括页面渲染线程、JS线程等。它的缺点主要如下：

- 根据进程和线程的关系我们知道，一个线程挂了，其所在的整个进程都得挂，所以说第一个缺点是**不稳定**
- 根据进程和线程的关系我们又知道：同一个进程内的所有线程是无隐私共享数据的， JS线程能获得浏览器当前进程的所有数据，这是第二个缺点：**不安全**
- 还有就是一个线程负责的东西太多，这就导致第三个缺点：**不流畅**

# 现代化的多进程浏览器结构

现代浏览器是多进程的结构，简单来说，一个标签页就对应一个独立的渲染器进程。所以，你开很多少个标签页，就会启动多少个进程，这样虽然有点废内存空间，但确实是最安全的，因为不同标签页对应的不同进程之间互不影响。

现代浏览器根据功能不同，主要分为以下几种进程：

- 浏览器进程。这个进程负责**用户界面**，也就是地址栏，书签栏，前进后退按钮那一堆东西。另外这个进程也是个大组长，负责浏览器里面不同进程之间的工作协调
- 渲染器进程。 负责窗口的内容显示，每个标签页都会对应一个渲染器进程
- 网络进程。负责搞网络请求的
- GPU进程。就是个画图、绘制页面的
- 插件进程。负责管理浏览器插件（如flash）
- 缓存进程。负责搞缓存的

# 为什么说JS是单线程的

JS单线程指的是说：**在一个渲染器进程中，有且只有一个JS线程在工作。**

这样可以保证DOM的操作可靠性。加入有多个JS线程同时工作，一个JS线程在删除该DOM，另一个JS线程却在获取该DOM的信息，这样就没法保证操作的可靠性。

# JS线程与UI线程互斥的根本原因

这两者互斥的根本原因在于：**JS是可以操作DOM，导致样式改变的。**

假设有4个红色的div等待渲染到页面上，JS线程和UI线程同时启动。UI线程在拿着“4个红色div”的稿子老老实实画着图，JS线程来捣一手乱，把div改为蓝色同时数量缩减为3个。那代码跟页面展示效果就不一致了。

所以，为了避免这种代码数据跟页面展示不一致的异常情况，浏览器将JS线程和UI线程设置成了互斥的关系，当JS线程在干活时，UI线程会被挂起来，晾在一边乖乖等待。等到JS线程把活干完喘口气的时候，UI线程才会跑出来执行一遍。