## CSS 的加载会不会造成阻塞

**CSS 的加载不会阻塞 DOM 解析，但会阻塞 Render Tree 渲染。**

其实这个原理也很简单：Render Tree 是由 DOM Tree 和 CSSOM 组合形成的，所以它必须等到 DOM Tree 和 CSSOM 两个都加载完，才能进行合成。

而 DOM Tree 和 CSSOM 是并行构建、分头行动、互不影响的。

## 为什么有时候 JS 需要等待 CSS 文件的下载完成

简而言之：**JS 可能要获取 CSS 内容**。

首先，JS 文件和 CSS 文件是同时下载的，有时候 JS 下载得快，有时候 CSS 下载得快。

假设 JS 先下载完，由于浏览器并不能提前感知 JS 脚本的内容是干了啥，所以这时候不等待 CSS 下载完成，直接执行 JS 会有风险。比如：通过 JS 获取某个 div 的背景颜色和字体大小等，如果这些东西写在 CSS 样式表里，那么 JS 不等待 CSS 下载完成就直接执行，获取的背景颜色和字体大小就是错误的。

## 为什么建议把 CSS 放头部（head）？

把 CSS 放头部，可以尽早生成 CSSOM，等到 DOM Tree 生成完时直接合并成 Render Tree。

否则，如果放在 body 内部，容易出现执行到这里的时候，发现有 CSS 代码，从而加载生成 CSSOM，重新合成 Render Tree 引起回流，导致页面出现“样式突变”。

## 为什么建议 JS 放在 body 尾部？

因为 js 会阻塞渲染，放在尾部执行可以让能渲染出来的 HTML 元素先渲染出来，减少首屏时间。

## 图片会不会阻塞渲染？

不会。

## DOMContentLoaded 和 window.onload 的区别

正如名字说的那样，DOMContentLoaded 指的是 DOM 渲染完了就执行，此时图片、视频等外部资源可能还没加载完；

而 window.onload 指的是页面的全部资源加载完了才执行，包括图片、视频那些。

如果我们要在页面加载完后去做一些事情，一般监听 DOMContentLoaded 就行了，因为我们监听页面加载完后去做的事情**往往都跟 DOM 相**关。至于图片、视频有没有全部下载完，我们是很少关心的。

## 在地址栏输入一个 URL 时，具体发生了什么？（很具体的那种）

### 资源形式有哪些

我们输入 URL，实际上是在向服务器请求资源，资源有哪些种类呢？

1. html 文件，这个最常见
2. 一些媒体文件，比如说图片、视频等
3. js、css

### 大体步骤

我们可以把这里分为五部分，以后我们讨论这个问题答案就是五部分，天王老子来了它也是五部分：

1. DNS 解析
2. TCP 连接
3. 客户端发送 HTTP 请求
4. 服务器响应 HTTP 请求
5. 浏览器解析渲染

### 第一部分 DNS 解析

其实在这步之前，还有两个过程：就是构建网络请求，以及查找浏览器缓存（强缓存/协商缓存）。

在构建网络请求之前，有一个动作捕获的过程，UI 线程会捕捉地址栏中的地址栏内容，然后网络线程会负责对地址栏内容做前置处理，比如说是关键字的话，就移交给搜索引擎；是 URL 的话，就先检查一下是不是恶意站点，如果不是，就移交给 DNS 做下一步处理。

首先我们搞明白一件事，DNS 解析，其实就是：**域名转换为 IP 地址的过程**。这里是不涉及端口号的。

它的查找优先级是这样的：

1. 本地 DNS 缓存；
2. 系统配置的 DNS 服务器；
3. DNS 根服务器。

### 第二部分 TCP 连接

在正式发送 HTTP 请求之前，需要建立 TCP 连接，这里主要涉及到的就是 TCP 的三次握手。在 TCP 那一章已经说了。

如果访问的是接口是 HTTPS，那在 TCP 握手完成之后，还要进行 TLS 握手。

### 第三部分 浏览器发起 http 请求

这里会展示一个 HTTP 请求如何发送，会涉及到 TCP/IP 协议族的四层模型。

应用层数据 --> 下沉到传输层，添加来源端口和目标端口号 --> 下沉到网络层，加上源 IP 地址和目标 IP 地址 --> 下沉到链路层，转成电信号发给服务器。

### 第四部分 服务器处理 http 请求，并将资源返还给浏览器

服务器要处理这个请求，对请求的处理在 TCP/IP 协议族中是自下而上的，会经历一个类似“拆快递”的过程，最终将客户端的 HTTP 请求传给顶层的应用层。然后服务器经过一系列操作（查询数据库之类），将相应资源返还给客户端。

### 第五部分 浏览器解析渲染

如果返回的是 html 代码，那会经历如下过程：

1. 根据 HTML 生成 DOM Tree；
2. 根据 CSS 代码生成 CSSOM；
3. DOM Tree 和 CSSOM 结合生成 Render Tree;
4. 浏览器根据 Render Tree 渲染页面。（如果遇到 script 则暂停渲染，执行完 script 再继续渲染）。

为什么渲染过程中遇到 script 要优先执行 script？_因为 JS 可能会改变 DOM 结构_。

## 重绘和回流

- 重绘（repaint），是指只改变外观，不改变布局的操作，对页面影响不是很大；
- 回流（reflow），也叫“重排”，是指布局/几何属性改变了，回流一定会引起重绘，对页面性能影响较大，需要尽量减少。

其中，建议不要使用table进行页面布局（当然现在一般也不会这么干），因为对table布局里面任何一个元素对小改动都会造成整个table的重新布局，引发回流，性能不好。

为什么要避免重绘和回流呢？因为这两个东西都运行在主线程中，占用主线程意味着JS对主线程的使用会减少，容易出现抢占主线程的问题。

而使用`transform`不会引起重绘和重排，因为`transform`在栅格化阶段，不用和JS抢夺主线程。
