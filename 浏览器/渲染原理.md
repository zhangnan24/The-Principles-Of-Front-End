# CSS 的加载会不会造成阻塞

**CSS 的加载不会阻塞 DOM 解析，但会阻塞 Render Tree 渲染。**

其实这个原理也很简单：Render Tree 是由 DOM Tree 和 CSSOM 组合形成的，所以它必须等到 DOM Tree 和 CSSOM 两个都加载完，才能进行合成。

而 DOM Tree 和 CSSOM 是并行构建、分头行动、互不影响的。

# 在地址栏输入一个 URL 时，具体发生了什么？（很具体的那种）

我们可以把这里分为三部分：**捕捉输入、连接传输、解析渲染**。

## 第一部分 捕捉输入

1. 负责用户界面这一块的**浏览器进程**中的 UI 线程小弟会捕捉用户的输入内容， 因为我们输入的是 URL 网址，则 UI 线程小弟会直接懵逼，它会喊来更为专业的网络线程兄弟来帮忙，把 URL 地址转交给这个网络线程兄弟。（如果输入的不是网址，而是一些搜索关键词，那么浏览器就会使用默认的搜索引擎根据输入的关键词进行搜索，这里就不做讨论了）

2. 网络线程兄弟现在拿到了 URL，它首先启动`safeBrowsing`（谷歌内置安全系统）来检查检查这个 URL 是不是恶意站点，这个检测的原理应该类似于去一个 URL 黑名单里面找，如果找到了则认为这个 URL 是恶意网址，这时候就会跳转到一个浏览器自带的警告页，并询问用户是否一意孤行地坚持强行访问这个恶意站点。如果没找着，那么，就可以开始尝试解析这个 URL 了

3. 解析 URL 是通过 DNS 来完成的，大体流程是：依次访问 本地缓存 --> 系统配置的 DNS 服务器 --> DNS 根服务器。一旦找到则停止迭代查询。这里我们要明白一点，DNS并不具备解析出端口号的能力，它只关注URL到IP地址的转换。但是浏览器是可以根据URL格式确定端口号的。

- 如果用户输入的URl中带了端口号，则优先采用该端口号
- 如果没写端口号，则需要看URL格式：没写协议或写了http协议，默认分配80端口；写了https协议的，默认分配443端口

## 第二部分 连接传输

1. 现在IP地址和端口号都知道了，客户端知道消息要发给谁了。现在客户端有一个请求数据（“我要获取哪哪哪的html文件”），但是这个数据还不能直接发，我们需要将这个数据包装一下，就好像发快递之前要将快递打包📦一样。

2. 现在数据包先跑到应用层, 选择http/https协议 --> 下沉到传输控制层，把来源端口和目标端口号加进去 --> 继续下沉到网络层，加上源IP地址和目标IP地址 --> 最终下沉到链路层，网络信号此时将被转成电信号，通过物理电缆传输到服务器。


经过一系列的数据拉取后...网络线程把服务端传回来的数据送给 UI 线程小弟，算是帮了 UI 线程一个大忙。

3. 现在 UI 线程小弟知道了这个网址是安全的，是时候开始通知窗口渲染了。所以它现在需要启动一个当前浏览器进程之外的进程： **渲染器进程**。并通过 IPC 通信管道将 HTML 数据传输给渲染器进程

4. 渲染器进程现在接收到的就是 HTML 数据，它接下来要做的事情，就是把 HTML 文件里面的这些外部资源（CSS、JS 脚本、图片）和自身代码渲染成 web 页面

5. 渲染器的主线程
