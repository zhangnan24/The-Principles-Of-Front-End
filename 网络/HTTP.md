# 对称加密与非对称加密

## 对称加密

对称加密，也就是 AES，指的是对于消息的加解密都用同一把钥匙 🔑，这个钥匙通常也被称为“对称钥”，这个对称钥是双方保密协商的。

AES 的特点是速度快，但是缺点是**网络直接明文传输对称钥**的时候，极易被中间人劫持，很不安全。

## 非对称加密

非对称加密，也就是 RSA。指的是给消息进行加密时，会用到两把配套的钥匙（公钥+私钥），公钥是公开的，私钥是私密的。

公钥加密，对应的私钥可以解密；私钥加密，对应的公钥可以解密；两者角色可以互相交换，又相辅相成。

RSA 速度比 AES 慢上百倍。优点？在遇到 https 之前是不存在的，同样可以被中间人劫持。

> RSA 的劫持会稍微复杂一点，在一开始的双方公钥交换时，中间人劫持了双方的公钥，并用自己的公钥作为冒充发送给双方。以后双方的通信都用中间人的公钥加密，中间人劫持后用自己的私钥解密，再用对方的公钥加密发给对方。也就是说，中间人现在有三把公钥。

但是，如果能证明公钥的来源，非法劫持后会导致认证失败就好了。所以，RSA 安全传输的优点，要遇到 https 才能显现出来，因为 https 可以证明公钥来源。

## 组合加密

AES 的优点是速度快，痛点是对称钥无法安全传输；RSA+https 的痛点是速度慢，传输安全。

综合以上两种加密算法的特点，衍生了一个最佳方案 ☝️：

1. 第一次通信时，用 RSA 安全传输对称钥；

2. 以后的通信，都用该对称钥进行 AES 加解密。

# 认识 HTTP 协议

HTTP 协议由客户端和服务器两个实体构成，工作方式为：客户端发送请求 --- 服务器返回响应。

在 HTTP 协议中，传输的数据被称为资源，资源可以是图片、视频、html 文件。资源是通过 URL 来进行精确定位的。

## URL 的组成

URL 由协议（protocol）、主机名（host）、路径（path）、查询参数（query）四部分组成。

如： `https://search.jd.com/Search?keyword=iPhone&wq=502`，解析结果为：

- 协议： `https://`
- 主机名： `search.jd.com`
- 路径： `/Search`
- 查询参数：`?keyword=iPhone&wq=502`

## HTTP 请求由哪几部分构成

一般由 4 或 5 部分构成，如下：

- 请求方式。`GET/POST/PUT/DELETE`
- 路径与查询参数。`Path + query`（如果有）
- HTTP 版本。如`HTTP1.1`
- 请求头。`Request Header`
- 请求体（一般 POST/PUT 请求才有）。`Request Body`

## HTTP 响应由哪几部分组成

一般由 这几部分组成，如下：

- HTTP 版本。如`HTTP1.1`
- 响应状态码。(100~600 不等)
- 响应头。`Response Header`，可以在这里面设置 max-age 等用于告知客户端如何控制缓存
- 响应体。`Response Body`

HTTP 协议是无状态的，服务端没法知道这条请求和上一条请求是否来自同一个客户端，**因此一般会利用 Cookie 来保持会话、记录状态。**尤其是对于类似购物车或者登录的功能，保持会话是一种强需求。

## HTTP2 比 HTTP1.1 升级在哪

简单认知以下，最明显的改变是： HTTP2 不再是文本传输了，而是二进制传输。

# HTTPS 和 HTTP 有何区别？

要说这个，首先要看看 HTTPS 和 HTTP 有啥区别？

首先，HTTP 无论是 1.1 版本还是 2 版本，都是明文传输的。

因为这种传输涉及很多敏感信息，为了加强安全性，SSL 协议应运而生。SSL 是由网景推出的一种安全加密协议，用于*对网络传输的文本数据进行安全加解密*。后来被 IETF（互联网工程任务组）规范化了，并重新命名为 TLS。可以说，TLS 就是规范版的 SSL。

## TLS 握手

与 HTTP 协议不同，HTTPS 协议会在双方正式通信之前，先进行 TLS 握手 🤝。TLS 握手的本质，**其实就是为了安全地传输对称钥**。

安全传输完对称钥后，以后的通信都会使用这个对称钥进行加解密。

让我们看看 TLS 是如何尽忠职守地护送对称钥安全到达彼岸：

1. 交换随机数。（即客户端和服务器会互相发送 TLS 版本、加密算法，并交换各自的随机数）；
2. 服务器向客户端发送数字证书。（数字证书里面包含了服务器的公钥）；
3. 客户端根据操作系统/浏览器的内置本地 CA 列表来验证证书合法性，如果验证通过，则客户端会随机生成一个`pre-master secret`（其实就是对称钥的前身），并放心使用证书内含的服务器公钥将其加密，发回给服务器；
4. 服务器接收后，用自己的私钥解密，得到`pre-master secret`;
5. 浏览器和服务器各自根据`pre-master secret + 客户端随机数 + 服务器随机数`，使用相同的算法生成`master key`，也就是对称钥。

后面双方的正式通信都使用这个`master key`进行消息的加解密。

## HTTP 的长连接和短连接

首先，HTTP 的长连接和短连接，实质上就是 TCP 的长连接和短连接，因为 HTTP 是应用层协议，TCP 才是传输层协议。

那么啥是长连接，啥是短连接呢？**长连接就是一次连接可以发送多次数据包**，那毫无疑问，**短连接则是一次连接只能发送一次数据包**。

在 HTTP1.0 中，默认是使用短连接，就是说每次向服务器发起请求都需要建立 TCP 连接，众所周知，TCP 的连接的建立是需要三次握手的，这样的话，耗时会比较久。

而在 HTTP1.1 中，默认是使用长连接。在 HTTP1.1 的请求头上，会默认加上这行代码：

```js
Connection: keep-alive;
```

这样的话，客户端和服务器在进行完一次请求后，并不会马上进行 TCP 四次挥手将这个连接通道关闭，而是会保持一段时间。

当然，这个 keep-alive 是由客户端发起建议，服务端响应建议的，就是说要客户端和服务端同时支持才行。

而至于一个 TCP 连接可以复用多久，复用多少次，这就涉及到一些长连接的保持策略了，比如当服务器与客户端建立的长连接数量过多时，会采取一些策略关闭掉长时间没发起请求的长连接。

或者也可以通过客户端发起建议来设置：(客户端请求头)，服务端需要解析该设置。

```js
Keep-Alive: timeout=5, max=100 // 表示这个长连接5s过期，在5s內最多承载100次请求，超过100次则强制断掉
```

目前的浏览器情况来说，大部分都是用 http1.1 协议，就是说默认都会在请求头发送`Connection: keep-alive`。那长连接的优点可以总结为：**减少了 TCP 的连接数，也就减少了网络拥塞**。

## HTTP 长连接模式，客户端怎么判断一次数据包传输已经完成

对于过去的短连接模式，因为一次连接对应一次数据包传输，所以当连接关闭的时候，也就意味着这次数据包传输完成了。

那在长连接模式，一次连接可以传输多次数据包，那怎么判断某一次传输有没有完成呢？

- **`content-length`**。通过响应头的`content-length`来判断，因为服务端是知道这个数据包的大小的，当客户端本次接收的数据包大小达到`content-Length`，就说明本次数据包传输完成了，这也是最普遍的做法；
- **`transfer-encoding`**。表示分块传输，这个常见于一些动态内容，就是说服务器事先也不知道内容到底有多大，就直接发送数据。采用分块传输时，最后一个分块长度值必须为 0，这样就可以判断本次数据包传输完成。从试验来看，这个字段只在`HTTP1.1`中会出现，在`HTTP2`中响应头没有该字段。
