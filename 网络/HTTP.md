# 对称加密与非对称加密

## 对称加密

对称加密，也就是 AES，指的是对于消息的加解密都用同一把钥匙 🔑，这个钥匙通常也被称为“对称钥”，这个对称钥是双方保密协商的。

AES 的特点是速度快，但是缺点是**网络直接明文传输对称钥**的时候，极易被中间人劫持，很不安全。

## 非对称加密

非对称加密，也就是 RSA。指的是给消息进行加密时，会用到两把配套的钥匙（公钥+私钥），公钥是公开的，私钥是私密的。

公钥加密，对应的私钥可以解密；私钥加密，对应的公钥可以解密；两者角色可以互相交换，又相辅相成。

RSA 速度比 AES 慢上百倍。优点？在遇到 https 之前是不存在的，同样可以被中间人劫持。

> RSA 的劫持会稍微复杂一点，在一开始的双方公钥交换时，中间人劫持了双方的公钥，并用自己的公钥作为冒充发送给双方。以后双方的通信都用中间人的公钥加密，中间人劫持后用自己的私钥解密，再用对方的公钥加密发给对方。也就是说，中间人现在有三把公钥。

但是，如果能证明公钥的来源，非法劫持后会导致认证失败就好了。所以，RSA 安全传输的优点，要遇到 https 才能显现出来，因为 https 可以证明公钥来源。

## 组合加密

AES 的优点是速度快，痛点是对称钥无法安全传输；RSA+https 的痛点是速度慢，传输安全。

综合以上两种加密算法的特点，衍生了一个最佳方案 ☝️：

1. 第一次通信时，用 RSA 安全传输对称钥；

2. 以后的通信，都用该对称钥进行 AES 加解密。

# 认识 HTTP 协议

HTTP 协议由客户端和服务器两个实体构成，工作方式为：客户端发送请求 --- 服务器返回响应。

在 HTTP 协议中，传输的数据被称为资源，资源可以是图片、视频、html 文件。资源是通过 URL 来进行精确定位的。

## URL 的组成

URL 由协议（protocol）、主机名（host）、路径（path）、查询参数（query）四部分组成。

如： `https://search.jd.com/Search?keyword=iPhone&wq=502`，解析结果为：

- 协议： `https://`
- 主机名： `search.jd.com`
- 路径： `/Search`
- 查询参数：`?keyword=iPhone&wq=502`

## HTTP 请求由哪几部分构成

一般由 4 或 5 部分构成，如下：

- 请求方式。`GET/POST/PUT/DELETE`
- 路径与查询参数。`Path + query`（如果有）
- HTTP 版本。如`HTTP1.1`
- 请求头。`Request Header`
- 请求体（一般 POST/PUT 请求才有）。`Request Body`

## HTTP 响应由哪几部分组成

一般由 这几部分组成，如下：

- HTTP 版本。如`HTTP1.1`
- 响应状态码。(100~600 不等)
- 响应头。`Response Header`，可以在这里面设置 max-age 等用于告知客户端如何控制缓存
- 响应体。`Response Body`

HTTP 协议是无状态的，服务端没法知道这条请求和上一条请求是否来自同一个客户端，**因此一般会利用 Cookie 来保持会话、记录状态。**尤其是对于类似购物车或者登录的功能，保持会话是一种强需求。

## HTTP2比HTTP1.1升级在哪

简单认知以下，最明显的改变是： HTTP2不再是文本传输了，而是二进制传输。


# HTTPS 和 HTTP 有何区别？

要说这个，首先要看看HTTPS和HTTP有啥区别？

首先，HTTP无论是1.1版本还是2版本，都是明文传输的。

因为这种传输涉及很多敏感信息，为了加强安全性，SSL协议应运而生。SSL 是由网景推出的一种安全加密协议，用于*对网络传输的文本数据进行安全加解密*。后来被 IETF（互联网工程任务组）规范化了，并重新命名为 TLS。可以说，TLS 就是规范版的 SSL。

## TLS握手

与HTTP协议不同，HTTPS协议会在双方正式通信之前，先进行TLS握手🤝。TLS握手的本质，**其实就是为了安全地传输对称钥**。

安全传输完对称钥后，以后的通信都会使用这个对称钥进行加解密。

让我们看看TLS是如何尽忠职守地护送对称钥安全到达彼岸：


1. 交换随机数。（即客户端和服务器会互相发送TLS版本、加密算法，并交换各自的随机数）；
2. 服务器向客户端发送数字证书。（数字证书里面包含了服务器的公钥）；
3. 客户端根据操作系统/浏览器的内置本地CA列表来验证证书合法性，如果验证通过，则客户端会随机生成一个`pre-master secret`（其实就是对称钥的前身），并放心使用证书内含的服务器公钥将其加密，发回给服务器；
4. 服务器接收后，用自己的私钥解密，得到`pre-master secret`;
5. 浏览器和服务器各自根据`pre-master secret + 客户端随机数 + 服务器随机数`，使用相同的算法生成`master key`，也就是对称钥。

后面双方的正式通信都使用这个`master key`进行消息的加解密。
